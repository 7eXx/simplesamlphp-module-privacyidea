<?php
/**
 * This authentication processing filter allows you to add a second step
 * authentication against privacyIDEA
 *
 * @author Cornelius Kölbel <cornelius.koelbel@netknights.it>
 * @author Jean-Pierre Höhmann <jean-pierre.hoehmann@netknights.it>
 */


class sspmod_privacyidea_Auth_Process_privacyidea extends SimpleSAML_Auth_ProcessingFilter
{
    /**
     * This contains the server configuration
     * @var array
     */
    private $serverconfig;

    /**
     * privacyidea constructor.
     *
     * @param array $config The configuration of this authproc.
     * @param mixed $reserved
     *
     * @throws \SimpleSAML\Error\CriticalConfigurationError in case the configuration is wrong.
     */
    public function __construct(array $config, $reserved)
    {
        assert('array' === gettype($config));

        SimpleSAML_Logger::info("Create the Auth Proc Filter privacyidea");
        parent::__construct($config, $reserved);
        $this->serverconfig = $config;
    }

    /**
     * Run the filter.
     *
     * @param array $state
     *
     * @throws \Exception if authentication fails
     */
    public function process(&$state)
    {
        assert('array' === gettype($state));

        SimpleSAML_Logger::info("privacyIDEA Auth Proc Filter: Entering process function");

        foreach ($state['privacyidea:serverconfig'] as $key => $value) {
            if (!isset($this->serverconfig[$key])) {$this->serverconfig[$key] = $value;}
        }

        // Find the first usable uidKey.
        if (gettype($this->serverconfig['uidKey']) === "array" && !empty($this->serverconfig['uidKey'])) {
            foreach ($this->serverconfig['uidKey'] as $uidKey) {
                if (isset($state['Attributes'][$uidKey][0])) {
                    $this->serverconfig['uidKey'] = $uidKey;
                    break;
                }
            }
        }

        $state['privacyidea:privacyidea'] = $this->serverconfig;

        if (isset($state[$this->serverconfig['enabledPath']][$this->serverconfig['enabledKey']][0])) {
            $piEnabled = $state[$this->serverconfig['enabledPath']][$this->serverconfig['enabledKey']][0];
        } else {
            $piEnabled = True;
        }

        if ($this->serverconfig['privacyideaserver'] === '') {
            $piEnabled = False;
            SimpleSAML_Logger::error("privacyIDEA url is not set!");
        }

        if ($piEnabled) {
            if ($this->serverconfig['tryFirstAuthentication']) {
                if ($this->authenticate($state, $this->serverconfig['tryFirstAuthPass'], null, null, null, null)) {
                    return;
                }
                SimpleSAML_Logger::debug("privacyIDEA: user has token");
            }
            if ($this->serverconfig['doTriggerChallenge']) {
                $authToken = sspmod_privacyidea_Auth_utils::fetchAuthToken($this->serverconfig);
                $params = array(
                    "user" => $state["Attributes"][$this->serverconfig['uidKey']][0],
                );
                $headers = array(
                    "authorization:" . $authToken,
                );
                $body = sspmod_privacyidea_Auth_utils::curl($params, $headers, $this->serverconfig, "/validate/triggerchallenge", "POST");
                $state = sspmod_privacyidea_Auth_utils::checkTokenType($state, $body);
            }
            SimpleSAML_Logger::debug("privacyIDEA: privacyIDEA is enabled, so we use 2FA");
            $state['privacyidea:privacyidea:authenticationMethod'] = "authprocess";
            $id = SimpleSAML_Auth_State::saveState($state, 'privacyidea:privacyidea:init');
            SimpleSAML_Logger::debug("Saved state privacyidea:privacyidea:init from Process/privacyidea.php");
            $url = SimpleSAML_Module::getModuleURL('privacyidea/otpform.php');
            SimpleSAML_Utilities::redirectTrustedURL($url, array('StateId' => $id));
        } else {
            SimpleSAML_Logger::debug("privacyIDEA: " . $this->serverconfig['enabledPath'] . " -> " . $this->serverconfig['enabledKey'] . " is not set to true -> privacyIDEA is disabled");
        }
    }

    /**
     * Perform 2FA authentication given the current state and an OTP from a token managed by privacyIDEA
     * The otp is sent to the privacyidea_url.
     *
     * @param array $state The state array in the "privacyidea:privacyidea:init" stage.
     * @param string $otp A one time password generated by a yubikey.
     * @return boolean True if authentication succeeded and the key belongs to the user, false otherwise.
     *
     * @throws \InvalidArgumentException if the state array is not in a valid stage or the given OTP has incorrect
     * length.
     */
    public static function authenticate(array &$state, $otp, $transaction_id, $signaturedata, $clientdata, $registrationdata)
    {
        assert('array' === gettype($state));
        assert('string' === gettype($otp));

        $cfg = $state['privacyidea:privacyidea'];

        $params = array(
            "user" => $state["Attributes"][$cfg['uidKey']][0],
            "pass" => $otp,
            "realm" => $cfg['realm'],
        );
        if ($transaction_id) {
            SimpleSAML_Logger::debug("Authenticating with transaction_id: " . $transaction_id);
            $params["transaction_id"] = $transaction_id;
        }
        if ($signaturedata) {
            SimpleSAML_Logger::debug("Authenticating with signaturedata: " . urlencode($signaturedata));
            $params["signaturedata"] = $signaturedata;
        }
        if ($clientdata) {
            SimpleSAML_Logger::debug("Authenticating with clientdata: " . urlencode($clientdata));
            $params["clientdata"] = $clientdata;
        }
        if ($registrationdata) {
            SimpleSAML_Logger::debug("Authenticating with regdata: " . urlencode($registrationdata));
            $params["regdata"] = $registrationdata;
        }
        $multi_challenge = NULL;

        if (isset($state['privacyidea:tokenEnrollment']['enrollU2F']) && $transaction_id) {
            $params['type'] = "u2f";
            $params['description'] = "Enrolled with simpleSAMLphp";
            $params['serial'] = $state['privacyidea:tokenEnrollment']['serial'];
            $authToken = $state['privacyidea:tokenEnrollment']['authToken'];
            $headers = array(
                "authorization: " . $authToken,
            );
            sspmod_privacyidea_Auth_utils::curl($params, $headers, $cfg, "/token/init", "POST");
            return true;
        }
        $body = sspmod_privacyidea_Auth_utils::curl($params, null, $cfg, "/validate/samlcheck", "POST");
        $auth = sspmod_privacyidea_Auth_utils::nullCheck(@$body->result->value->auth);
        $status = @$body->result->status;

        if ($status !== true) {
            throw new SimpleSAML_Error_BadRequest("privacyIDEA: Valid JSON response, but some internal error occured in PI server");
        }
        if ($auth !== true) {
            if (property_exists($body, "detail")) {
                $detail = $body->detail;
                if (property_exists($detail, "multi_challenge")) {

                    $state = sspmod_privacyidea_Auth_utils::checkTokenType($state, $body);

                    SimpleSAML_Logger::debug("privacyIDEA: privacyIDEA is enabled, so we use 2FA");
                    $id = SimpleSAML_Auth_State::saveState($state, 'privacyidea:privacyidea:init');
                    SimpleSAML_Logger::debug("Saved state privacyidea:privacyidea:init from Process/privacyidea.php");
                    $url = SimpleSAML_Module::getModuleURL('privacyidea/otpform.php');
                    SimpleSAML_Utilities::redirectTrustedURL($url, array('StateId' => $id));
                    return true;
                } else {
                    SimpleSAML_Logger::error("privacyIDEA WRONG USER PASSWORD");
                    return false;
                }
            } else {
                return false;
            }
        }

        SimpleSAML_Logger::debug("privacyIDEA: User authenticated successfully");
        return true;
    }

}
